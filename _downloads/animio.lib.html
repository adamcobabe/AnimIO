<html>
<head>
<title>animio.lib</title>
</head>
<body>
animio.lib
<style>
.coverage pre {float: left; margin: 0px 1em; border: none;
               padding: 0px; }
.num pre { margin: 0px }
.nocov, .nocov pre {background-color: #faa}
.cov, .cov pre {background-color: #cfc}
div.coverage div { clear: both; height: 1.1em}
</style>
<div class="stats">
Covered: 201 lines<br/>
Missed: 2 lines<br/>
Skipped 110 lines<br/>
Percent: 99 %<br/>

</div>
<div class="coverage">
<div class="skip"><span class="num"><pre>  1</pre></span><pre># -*- coding: utf-8 -*-</pre></div>
<div class="cov"><span class="num"><pre>  2</pre></span><pre>&quot;&quot;&quot;This module contains classes and utilities affiliated with the import and export</pre></div>
<div class="cov"><span class="num"><pre>  3</pre></span><pre>of animation.&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>  4</pre></span><pre>__docformat__ = &quot;restructuredtext&quot;</pre></div>
<div class="skip"><span class="num"><pre>  5</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre>  6</pre></span><pre>import mrv.maya.nt as nt</pre></div>
<div class="cov"><span class="num"><pre>  7</pre></span><pre>from mrv.maya.ns import Namespace</pre></div>
<div class="cov"><span class="num"><pre>  8</pre></span><pre>from mrv.maya.ref import FileReference</pre></div>
<div class="cov"><span class="num"><pre>  9</pre></span><pre>from mrv.maya.scene import Scene</pre></div>
<div class="cov"><span class="num"><pre> 10</pre></span><pre>from mrv.maya.undo import UndoRecorder</pre></div>
<div class="cov"><span class="num"><pre> 11</pre></span><pre>from mrv.path import Path</pre></div>
<div class="skip"><span class="num"><pre> 12</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 13</pre></span><pre>import maya.OpenMayaAnim as apianim</pre></div>
<div class="cov"><span class="num"><pre> 14</pre></span><pre>import maya.cmds as cmds</pre></div>
<div class="skip"><span class="num"><pre> 15</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 16</pre></span><pre>import logging</pre></div>
<div class="cov"><span class="num"><pre> 17</pre></span><pre>log = logging.getLogger(&quot;animio.lib&quot;)</pre></div>
<div class="skip"><span class="num"><pre> 18</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 19</pre></span><pre>__all__ = ('AnimInOutLibrary', 'AnimationHandle')</pre></div>
<div class="skip"><span class="num"><pre> 20</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 21</pre></span><pre></pre></div>
<div class="skip"><span class="num"><pre> 22</pre></span><pre></pre></div>
<div class="cov"><span class="num"><pre> 23</pre></span><pre>class AnimInOutLibrary( object ):</pre></div>
<div class="cov"><span class="num"><pre> 24</pre></span><pre>	&quot;&quot;&quot;contains default implementation for animation export and import&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre> 25</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre> 26</pre></span><pre>	#{ Export/Import/Load</pre></div>
<div class="cov"><span class="num"><pre> 27</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre> 28</pre></span><pre>	@notundoable</pre></div>
<div class="cov"><span class="num"><pre> 29</pre></span><pre>	def export(cls, destination_file, iter_nodes,  **kwargs):</pre></div>
<div class="cov"><span class="num"><pre> 30</pre></span><pre>		&quot;&quot;&quot;Export animation retrieved from the given node iterator to the destination_file.</pre></div>
<div class="skip"><span class="num"><pre> 31</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre> 32</pre></span><pre>		:param destination_file: file to which to export the animation to</pre></div>
<div class="cov"><span class="num"><pre> 33</pre></span><pre>		:param iter_nodes: iterator yielding nodes in a format compatible to ``AnimationHandle.set_animation``</pre></div>
<div class="cov"><span class="num"><pre> 34</pre></span><pre>		:param **kwargs: passed to ``Scene.export``</pre></div>
<div class="cov"><span class="num"><pre> 35</pre></span><pre>		:raise ValueError: if the passed in nodes have no animation</pre></div>
<div class="cov"><span class="num"><pre> 36</pre></span><pre>		:return: destination_file as Path&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 37</pre></span><pre>		rec = UndoRecorder()</pre></div>
<div class="cov"><span class="num"><pre> 38</pre></span><pre>		rec.startRecording()</pre></div>
<div class="cov"><span class="num"><pre> 39</pre></span><pre>		tmphandle = AnimationHandle()</pre></div>
<div class="cov"><span class="num"><pre> 40</pre></span><pre>		tmphandle.set_animation(iter_nodes)</pre></div>
<div class="cov"><span class="num"><pre> 41</pre></span><pre>		rec.stopRecording()</pre></div>
<div class="skip"><span class="num"><pre> 42</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre> 43</pre></span><pre>		try:</pre></div>
<div class="cov"><span class="num"><pre> 44</pre></span><pre>			try:</pre></div>
<div class="cov"><span class="num"><pre> 45</pre></span><pre>				tmphandle.iter_animation().next()</pre></div>
<div class="cov"><span class="num"><pre> 46</pre></span><pre>			except StopIteration:</pre></div>
<div class="cov"><span class="num"><pre> 47</pre></span><pre>				raise ValueError(&quot;Given nodes did not have any animation&quot;)</pre></div>
<div class="skip"><span class="num"><pre> 48</pre></span><pre>			# END check for animation</pre></div>
<div class="skip"><span class="num"><pre> 49</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre> 50</pre></span><pre>			tmphandle.to_file(destination_file)</pre></div>
<div class="cov"><span class="num"><pre> 51</pre></span><pre>			return Path(destination_file)</pre></div>
<div class="cov"><span class="num"><pre> 52</pre></span><pre>		finally:</pre></div>
<div class="cov"><span class="num"><pre> 53</pre></span><pre>			rec.undo()</pre></div>
<div class="skip"><span class="num"><pre> 54</pre></span><pre>		# END revert to previous state</pre></div>
<div class="skip"><span class="num"><pre> 55</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre> 56</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre> 57</pre></span><pre>	#} END Export/Import/Load</pre></div>
<div class="skip"><span class="num"><pre> 58</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre> 59</pre></span><pre>	#{ Query</pre></div>
<div class="skip"><span class="num"><pre> 60</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre> 61</pre></span><pre>	#} END query</pre></div>
<div class="skip"><span class="num"><pre> 62</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 63</pre></span><pre>	def _create_plug_node( self ):</pre></div>
<div class="nocov"><span class="num"><pre> 64</pre></span><pre>		raise NotImplementedError(&quot;todo&quot;)</pre></div>
<div class="skip"><span class="num"><pre> 65</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre> 66</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 67</pre></span><pre>class AnimationHandle( nt.Network ):  </pre></div>
<div class="cov"><span class="num"><pre> 68</pre></span><pre>	__mrv_virtual_subtype__ = True</pre></div>
<div class="skip"><span class="num"><pre> 69</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 70</pre></span><pre>	_l_connection_info_attr = 'connectionInfo'</pre></div>
<div class="cov"><span class="num"><pre> 71</pre></span><pre>	_s_connection_info_attr = 'cifo'</pre></div>
<div class="cov"><span class="num"><pre> 72</pre></span><pre>	_k_separator = ','</pre></div>
<div class="cov"><span class="num"><pre> 73</pre></span><pre>	_networktype = nt.api.MFn.kAffect</pre></div>
<div class="skip"><span class="num"><pre> 74</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre> 75</pre></span><pre>	def __new__( cls, *args ): </pre></div>
<div class="cov"><span class="num"><pre> 76</pre></span><pre>		if not args:</pre></div>
<div class="cov"><span class="num"><pre> 77</pre></span><pre>			return cls.create()</pre></div>
<div class="skip"><span class="num"><pre> 78</pre></span><pre>		# END empty args create new node ( without calling __init__ )</pre></div>
<div class="skip"><span class="num"><pre> 79</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre> 80</pre></span><pre>		self=super(AnimationHandle, cls).__new__(cls, *args)</pre></div>
<div class="cov"><span class="num"><pre> 81</pre></span><pre>		if not cls._is_handle(self):</pre></div>
<div class="cov"><span class="num"><pre> 82</pre></span><pre>			raise TypeError('%r is not a valid %s' % (self, cls))</pre></div>
<div class="skip"><span class="num"><pre> 83</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre> 84</pre></span><pre>		return self</pre></div>
<div class="skip"><span class="num"><pre> 85</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre> 86</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre> 87</pre></span><pre>	def _is_handle( cls, ah ):</pre></div>
<div class="cov"><span class="num"><pre> 88</pre></span><pre>		&quot;&quot;&quot;:return: True if ah in a propper AnimationHandle&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 89</pre></span><pre>		return hasattr(ah, cls._s_connection_info_attr)</pre></div>
<div class="skip"><span class="num"><pre> 90</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre> 91</pre></span><pre>	#{ Iteration </pre></div>
<div class="cov"><span class="num"><pre> 92</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre> 93</pre></span><pre>	def iter_instances( cls, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre> 94</pre></span><pre>		&quot;&quot;&quot;:return: iterator yielding AnimationHandle instances of scene&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre> 95</pre></span><pre>		it=nt.it.iterDgNodes( cls._networktype, asNode=1, **kwargs )</pre></div>
<div class="cov"><span class="num"><pre> 96</pre></span><pre>		for node in it:</pre></div>
<div class="cov"><span class="num"><pre> 97</pre></span><pre>			if cls._is_handle(node):</pre></div>
<div class="cov"><span class="num"><pre> 98</pre></span><pre>				yield cls(node.object())</pre></div>
<div class="skip"><span class="num"><pre> 99</pre></span><pre>			# END if it is our node</pre></div>
<div class="skip"><span class="num"><pre>100</pre></span><pre>		#  END for each node </pre></div>
<div class="skip"><span class="num"><pre>101</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>102</pre></span><pre>	def iter_animation( self, asNode=True ):</pre></div>
<div class="cov"><span class="num"><pre>103</pre></span><pre>		&quot;&quot;&quot;:return: iterator yielding managed animation curves as wrapped Node or MObject</pre></div>
<div class="cov"><span class="num"><pre>104</pre></span><pre>		:param asNode: if true, iterator yields Node instances else MObjects&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>105</pre></span><pre>		for anim_node_dest_plug in self.affectedBy:</pre></div>
<div class="cov"><span class="num"><pre>106</pre></span><pre>			miplug=anim_node_dest_plug.minput()</pre></div>
<div class="cov"><span class="num"><pre>107</pre></span><pre>			if asNode:</pre></div>
<div class="cov"><span class="num"><pre>108</pre></span><pre>				yield miplug.mwrappedNode()</pre></div>
<div class="cov"><span class="num"><pre>109</pre></span><pre>			else:</pre></div>
<div class="cov"><span class="num"><pre>110</pre></span><pre>				yield miplug.node()</pre></div>
<div class="skip"><span class="num"><pre>111</pre></span><pre>			# END if asNode</pre></div>
<div class="skip"><span class="num"><pre>112</pre></span><pre>		# END iterator</pre></div>
<div class="skip"><span class="num"><pre>113</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>114</pre></span><pre>	def iter_assignments( self, predicate=None, converter=None):</pre></div>
<div class="cov"><span class="num"><pre>115</pre></span><pre>		&quot;&quot;&quot;:return: iterator yielding source-target assignments as plugs in a tuple(source_plug, target_plug) </pre></div>
<div class="cov"><span class="num"><pre>116</pre></span><pre>		:param converter: if not None, the function returns the desired target plug name to use </pre></div>
<div class="cov"><span class="num"><pre>117</pre></span><pre>			instead of the given plug name. Its called as follows: (string) convert(source_plug, target_plugname).</pre></div>
<div class="cov"><span class="num"><pre>118</pre></span><pre>		:param predicate: if not None, after the converter function has been applied, </pre></div>
<div class="cov"><span class="num"><pre>119</pre></span><pre>			(bool) predicate(source_plug, target_plugname) returns True for each plug to be yielded  </pre></div>
<div class="cov"><span class="num"><pre>120</pre></span><pre>		:note: for now, if target_plug does not exist we just print a message and continue&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>121</pre></span><pre>		# get target strings as array</pre></div>
<div class="skip"><span class="num"><pre>122</pre></span><pre>		# mrv provides this:</pre></div>
<div class="cov"><span class="num"><pre>123</pre></span><pre>		target_plug_names = self.findPlug(self._s_connection_info_attr).masData().array()</pre></div>
<div class="skip"><span class="num"><pre>124</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>125</pre></span><pre>		assert len(target_plug_names) == len(self.affectedBy), &quot;Number of animation nodes out of sync with their stored targets&quot;</pre></div>
<div class="skip"><span class="num"><pre>126</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>127</pre></span><pre>		# make iterator yielding source and target plug objects</pre></div>
<div class="cov"><span class="num"><pre>128</pre></span><pre>		plug_sel_list = nt.api.MSelectionList()</pre></div>
<div class="cov"><span class="num"><pre>129</pre></span><pre>		mfndep = nt.api.MFnDependencyNode()</pre></div>
<div class="cov"><span class="num"><pre>130</pre></span><pre>		for index, anim_node_dest_plug in enumerate(self.affectedBy):</pre></div>
<div class="cov"><span class="num"><pre>131</pre></span><pre>			target_plug_name_list = target_plug_names[index].split(self._k_separator)</pre></div>
<div class="cov"><span class="num"><pre>132</pre></span><pre>			anim_node_msg_plug=anim_node_dest_plug.minput()</pre></div>
<div class="cov"><span class="num"><pre>133</pre></span><pre>			if anim_node_msg_plug.isNull():</pre></div>
<div class="cov"><span class="num"><pre>134</pre></span><pre>				log.warn(&quot;no animation curve found on %s&quot; % anim_node_dest_plug.mfullyQualifiedName())</pre></div>
<div class="cov"><span class="num"><pre>135</pre></span><pre>				continue</pre></div>
<div class="skip"><span class="num"><pre>136</pre></span><pre>			# END check for nullPlug</pre></div>
<div class="skip"><span class="num"><pre>137</pre></span><pre>				</pre></div>
<div class="cov"><span class="num"><pre>138</pre></span><pre>			mfndep.setObject(anim_node_msg_plug.node())</pre></div>
<div class="cov"><span class="num"><pre>139</pre></span><pre>			anim_node_otp_plug = mfndep.findPlug('o')</pre></div>
<div class="skip"><span class="num"><pre>140</pre></span><pre>				</pre></div>
<div class="skip"><span class="num"><pre>141</pre></span><pre>			# convert target names to actual plugs</pre></div>
<div class="cov"><span class="num"><pre>142</pre></span><pre>			for tindex, tplug_name in enumerate(target_plug_name_list):</pre></div>
<div class="cov"><span class="num"><pre>143</pre></span><pre>				if converter:</pre></div>
<div class="cov"><span class="num"><pre>144</pre></span><pre>					tplug_name = converter(anim_node_otp_plug, tplug_name)</pre></div>
<div class="skip"><span class="num"><pre>145</pre></span><pre>				# END handle converter</pre></div>
<div class="skip"><span class="num"><pre>146</pre></span><pre>				</pre></div>
<div class="cov"><span class="num"><pre>147</pre></span><pre>				if predicate and not predicate(anim_node_otp_plug, tplug_name):</pre></div>
<div class="cov"><span class="num"><pre>148</pre></span><pre>					continue</pre></div>
<div class="skip"><span class="num"><pre>149</pre></span><pre>				# END filter</pre></div>
<div class="skip"><span class="num"><pre>150</pre></span><pre>				</pre></div>
<div class="cov"><span class="num"><pre>151</pre></span><pre>				actual_plug = nt.api.MPlug()</pre></div>
<div class="cov"><span class="num"><pre>152</pre></span><pre>				try:</pre></div>
<div class="cov"><span class="num"><pre>153</pre></span><pre>					plug_sel_list.add(tplug_name)</pre></div>
<div class="cov"><span class="num"><pre>154</pre></span><pre>				except:</pre></div>
<div class="cov"><span class="num"><pre>155</pre></span><pre>					log.warn(&quot;target plug named %s does not exist&quot; % tplug_name)</pre></div>
<div class="cov"><span class="num"><pre>156</pre></span><pre>					continue</pre></div>
<div class="skip"><span class="num"><pre>157</pre></span><pre>				# END check if plug exists</pre></div>
<div class="skip"><span class="num"><pre>158</pre></span><pre>				</pre></div>
<div class="cov"><span class="num"><pre>159</pre></span><pre>				plug_sel_list.getPlug(tindex, actual_plug)</pre></div>
<div class="cov"><span class="num"><pre>160</pre></span><pre>				yield (anim_node_otp_plug, actual_plug)</pre></div>
<div class="skip"><span class="num"><pre>161</pre></span><pre>				# END for each plugname to convert</pre></div>
<div class="skip"><span class="num"><pre>162</pre></span><pre>								</pre></div>
<div class="skip"><span class="num"><pre>163</pre></span><pre>				# make sure it doesnt build up</pre></div>
<div class="cov"><span class="num"><pre>164</pre></span><pre>				plug_sel_list.clear()</pre></div>
<div class="skip"><span class="num"><pre>165</pre></span><pre>			# END for each anim node source plug</pre></div>
<div class="skip"><span class="num"><pre>166</pre></span><pre>		# END iterating  </pre></div>
<div class="skip"><span class="num"><pre>167</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>168</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>169</pre></span><pre>	#} END iteration</pre></div>
<div class="skip"><span class="num"><pre>170</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>171</pre></span><pre>	#{ Edit</pre></div>
<div class="skip"><span class="num"><pre>172</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>173</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre>174</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>175</pre></span><pre>	def create( cls, name=&quot;animationHandle&quot;, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre>176</pre></span><pre>		&quot;&quot;&quot;:return: New instance of our type providing the ``AnimationHandle`` interface</pre></div>
<div class="cov"><span class="num"><pre>177</pre></span><pre>		:param kwargs: Passed to ``createNode`` method of mrv&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>178</pre></span><pre>		mynode = nt.createNode(name, &quot;network&quot;, **kwargs)</pre></div>
<div class="skip"><span class="num"><pre>179</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>180</pre></span><pre>		# add our custom attribute</pre></div>
<div class="cov"><span class="num"><pre>181</pre></span><pre>		attr = nt.TypedAttribute.create(cls._l_connection_info_attr, cls._s_connection_info_attr,</pre></div>
<div class="cov"><span class="num"><pre>182</pre></span><pre>							nt.api.MFnData.kStringArray, nt.StringArrayData.create(list()))</pre></div>
<div class="cov"><span class="num"><pre>183</pre></span><pre>		mynode.addAttribute(attr)</pre></div>
<div class="cov"><span class="num"><pre>184</pre></span><pre>		return cls(mynode.object())</pre></div>
<div class="skip"><span class="num"><pre>185</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>186</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>187</pre></span><pre>	def clear( self ):</pre></div>
<div class="cov"><span class="num"><pre>188</pre></span><pre>		&quot;&quot;&quot;Forget our managed animation completely&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>189</pre></span><pre>		# clear array plug</pre></div>
<div class="cov"><span class="num"><pre>190</pre></span><pre>		for ip in self.affectedBy.minputs():</pre></div>
<div class="nocov"><span class="num"><pre>191</pre></span><pre>			ip.disconnectInput()</pre></div>
<div class="skip"><span class="num"><pre>192</pre></span><pre>		# END for each array item to disconnect</pre></div>
<div class="skip"><span class="num"><pre>193</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>194</pre></span><pre>		# clear connection data</pre></div>
<div class="cov"><span class="num"><pre>195</pre></span><pre>		dplug = self.findPlug(self._s_connection_info_attr)</pre></div>
<div class="cov"><span class="num"><pre>196</pre></span><pre>		dplug.setMObject(nt.StringArrayData.create(list()))</pre></div>
<div class="skip"><span class="num"><pre>197</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>198</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>199</pre></span><pre>	def set_animation( self, iter_nodes ):</pre></div>
<div class="cov"><span class="num"><pre>200</pre></span><pre>		&quot;&quot;&quot;Set this handle to manage the animation of the given nodes.</pre></div>
<div class="cov"><span class="num"><pre>201</pre></span><pre>			The previous animation information will be removed.</pre></div>
<div class="skip"><span class="num"><pre>202</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>203</pre></span><pre>		:param iter_nodes: MSelectionList or iterable of Nodes or api objects pointing </pre></div>
<div class="cov"><span class="num"><pre>204</pre></span><pre>			to nodes connected to animation.</pre></div>
<div class="cov"><span class="num"><pre>205</pre></span><pre>		:note: Will not raise if the nodes do not have any animation</pre></div>
<div class="cov"><span class="num"><pre>206</pre></span><pre>		:note: Heavily optimized for speed, hence we work directly with the </pre></div>
<div class="cov"><span class="num"><pre>207</pre></span><pre>			apiObjects, skipping the mrv layer as we are in a tight loop here&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>208</pre></span><pre>		self.clear()</pre></div>
<div class="cov"><span class="num"><pre>209</pre></span><pre>		anim_nodes = nt.AnimCurve.findAnimation(iter_nodes, asNode=False)</pre></div>
<div class="cov"><span class="num"><pre>210</pre></span><pre>		mfndep = nt.api.MFnDependencyNode()</pre></div>
<div class="cov"><span class="num"><pre>211</pre></span><pre>		def iter_plugs():</pre></div>
<div class="cov"><span class="num"><pre>212</pre></span><pre>			affected_by_plug = self.affectedBy</pre></div>
<div class="cov"><span class="num"><pre>213</pre></span><pre>			for pindex, apinode in enumerate(anim_nodes):</pre></div>
<div class="cov"><span class="num"><pre>214</pre></span><pre>				mfndep.setObject(apinode)</pre></div>
<div class="cov"><span class="num"><pre>215</pre></span><pre>				yield (mfndep.findPlug('msg'), affected_by_plug.elementByLogicalIndex(pindex))</pre></div>
<div class="skip"><span class="num"><pre>216</pre></span><pre>			# END for each pair to yield</pre></div>
<div class="skip"><span class="num"><pre>217</pre></span><pre>		# END iterator helper</pre></div>
<div class="skip"><span class="num"><pre>218</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>219</pre></span><pre>		iterator = iter_plugs()</pre></div>
<div class="cov"><span class="num"><pre>220</pre></span><pre>		nt.api.MPlug.mconnectMultiToMulti(iterator, force=False)</pre></div>
<div class="skip"><span class="num"><pre>221</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>222</pre></span><pre>		# add current connection info</pre></div>
<div class="skip"><span class="num"><pre>223</pre></span><pre>		# NOTE: We know that the anim-node is connected to something</pre></div>
<div class="skip"><span class="num"><pre>224</pre></span><pre>		# as this is the reason we retrieved it in the first place</pre></div>
<div class="skip"><span class="num"><pre>225</pre></span><pre>		# TODO: Deal with intermediate nodes</pre></div>
<div class="cov"><span class="num"><pre>226</pre></span><pre>		target_plug_strings = list()</pre></div>
<div class="cov"><span class="num"><pre>227</pre></span><pre>		for apinode in anim_nodes:</pre></div>
<div class="cov"><span class="num"><pre>228</pre></span><pre>			mfndep.setObject(apinode)</pre></div>
<div class="cov"><span class="num"><pre>229</pre></span><pre>			outputs = mfndep.findPlug('o').moutputs()</pre></div>
<div class="cov"><span class="num"><pre>230</pre></span><pre>			target_plug_strings.append(self._k_separator.join(p.mfullyQualifiedName() for p in outputs))</pre></div>
<div class="skip"><span class="num"><pre>231</pre></span><pre>		# END for each node</pre></div>
<div class="cov"><span class="num"><pre>232</pre></span><pre>		self.findPlug(self._s_connection_info_attr).setMObject(nt.StringArrayData.create(target_plug_strings))</pre></div>
<div class="skip"><span class="num"><pre>233</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>234</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>235</pre></span><pre>	def apply_animation( self, converter=None ):</pre></div>
<div class="cov"><span class="num"><pre>236</pre></span><pre>		&quot;&quot;&quot;Apply the stored animation by (re)connecting the animation nodes to their</pre></div>
<div class="cov"><span class="num"><pre>237</pre></span><pre>			respective target plugs</pre></div>
<div class="cov"><span class="num"><pre>238</pre></span><pre>		:param: converter see ``iter_assignments``</pre></div>
<div class="cov"><span class="num"><pre>239</pre></span><pre>			This allows you to perform any modifications to the target before it will be</pre></div>
<div class="cov"><span class="num"><pre>240</pre></span><pre>			connected.</pre></div>
<div class="cov"><span class="num"><pre>241</pre></span><pre>		:note: Will break existing destination connections&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>242</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>243</pre></span><pre>		# do actual connection ( best case is 38k connections per second )</pre></div>
<div class="cov"><span class="num"><pre>244</pre></span><pre>		iterator = self.iter_assignments(converter=converter)</pre></div>
<div class="cov"><span class="num"><pre>245</pre></span><pre>		nt.api.MPlug.mconnectMultiToMulti(iterator, force=True)</pre></div>
<div class="skip"><span class="num"><pre>246</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>247</pre></span><pre>	#} END edit</pre></div>
<div class="skip"><span class="num"><pre>248</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>249</pre></span><pre>	#{ Utilities</pre></div>
<div class="cov"><span class="num"><pre>250</pre></span><pre>	@undoable</pre></div>
<div class="cov"><span class="num"><pre>251</pre></span><pre>	def paste_animation( self, sTimeRange=tuple(), tTimeRange=tuple(), option=&quot;fitInsert&quot;, predicate=None, converter=None ):</pre></div>
<div class="cov"><span class="num"><pre>252</pre></span><pre>		&quot;&quot;&quot;paste the stored animation to their respective target animation curves, if target does not exist it will be created</pre></div>
<div class="cov"><span class="num"><pre>253</pre></span><pre>		:param sTimeRange: tuple of timerange passed to copyKey</pre></div>
<div class="cov"><span class="num"><pre>254</pre></span><pre>		:param tTimeRange: tuple of timerange passed to pasteKey</pre></div>
<div class="cov"><span class="num"><pre>255</pre></span><pre>		:param option: option on how to paste forwarded to pasteKey (useful: &quot;fitInsert&quot;, &quot;fitReplace&quot;, &quot;scaleInsert&quot;, &quot;scaleReplace&quot;)</pre></div>
<div class="cov"><span class="num"><pre>256</pre></span><pre>		:param predicate and converter: passed to ``iter_assignments``, see documentation there</pre></div>
<div class="cov"><span class="num"><pre>257</pre></span><pre>		:todo: handle if range is out of curve (error:nothing to paste from) - should paste the pose in this range&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>258</pre></span><pre>		iter_plugs=self.iter_assignments(predicate=predicate, converter=converter)</pre></div>
<div class="skip"><span class="num"><pre>259</pre></span><pre>		</pre></div>
<div class="skip"><span class="num"><pre>260</pre></span><pre>		# get animCurves form plugs and copy pate</pre></div>
<div class="cov"><span class="num"><pre>261</pre></span><pre>		for s_plug, t_plug in iter_plugs:</pre></div>
<div class="cov"><span class="num"><pre>262</pre></span><pre>			s_animcrv=s_plug.mwn()</pre></div>
<div class="skip"><span class="num"><pre>263</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre>264</pre></span><pre>			if apianim.MAnimUtil.isAnimated(t_plug):</pre></div>
<div class="cov"><span class="num"><pre>265</pre></span><pre>				t_animcrv=t_plug.minput().mwn()</pre></div>
<div class="cov"><span class="num"><pre>266</pre></span><pre>			else:</pre></div>
<div class="cov"><span class="num"><pre>267</pre></span><pre>				t_animcrv=nt.Node(apianim.MFnAnimCurve().create(t_plug))</pre></div>
<div class="skip"><span class="num"><pre>268</pre></span><pre>			# END get new or existing animCurve</pre></div>
<div class="skip"><span class="num"><pre>269</pre></span><pre>				</pre></div>
<div class="cov"><span class="num"><pre>270</pre></span><pre>			cmds.copyKey(s_animcrv, time=sTimeRange, option=&quot;curve&quot;  )</pre></div>
<div class="cov"><span class="num"><pre>271</pre></span><pre>			cmds.pasteKey(t_animcrv, time=tTimeRange, option=option)</pre></div>
<div class="skip"><span class="num"><pre>272</pre></span><pre>		 # END for each assignment</pre></div>
<div class="skip"><span class="num"><pre>273</pre></span><pre>			</pre></div>
<div class="skip"><span class="num"><pre>274</pre></span><pre>	#} END Utilities</pre></div>
<div class="skip"><span class="num"><pre>275</pre></span><pre>	</pre></div>
<div class="skip"><span class="num"><pre>276</pre></span><pre>	#{ File IO</pre></div>
<div class="skip"><span class="num"><pre>277</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>278</pre></span><pre>	@classmethod</pre></div>
<div class="cov"><span class="num"><pre>279</pre></span><pre>	@notundoable</pre></div>
<div class="cov"><span class="num"><pre>280</pre></span><pre>	def from_file( cls, input_file ):</pre></div>
<div class="cov"><span class="num"><pre>281</pre></span><pre>		&quot;&quot;&quot;references imput_file into scene by using an unique namespace, returning</pre></div>
<div class="cov"><span class="num"><pre>282</pre></span><pre>			FileReference as well as an iterator yielding AmimationHandles of input_file</pre></div>
<div class="skip"><span class="num"><pre>283</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre>284</pre></span><pre>		:return: tuple(FileReference, iterator of AnimationHandles)</pre></div>
<div class="cov"><span class="num"><pre>285</pre></span><pre>		:param input_file: valid path to a maya file&quot;&quot;&quot;</pre></div>
<div class="cov"><span class="num"><pre>286</pre></span><pre>		ahref=FileReference.create(input_file, loadReferenceDepth=&quot;topOnly&quot;)</pre></div>
<div class="cov"><span class="num"><pre>287</pre></span><pre>		refns=ahref.namespace()</pre></div>
<div class="cov"><span class="num"><pre>288</pre></span><pre>		return (ahref, cls.iter_instances(predicate = lambda x: x.namespace() == refns))</pre></div>
<div class="skip"><span class="num"><pre>289</pre></span><pre>	</pre></div>
<div class="cov"><span class="num"><pre>290</pre></span><pre>	@notundoable</pre></div>
<div class="cov"><span class="num"><pre>291</pre></span><pre>	def to_file( self, output_file, **kwargs ):</pre></div>
<div class="cov"><span class="num"><pre>292</pre></span><pre>		&quot;&quot;&quot;export the AnimationHandle and all managed nodes to the given file</pre></div>
<div class="skip"><span class="num"><pre>293</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>294</pre></span><pre>		:return: path to exported file</pre></div>
<div class="cov"><span class="num"><pre>295</pre></span><pre>		:param output_file: Path object or path string to export file.</pre></div>
<div class="cov"><span class="num"><pre>296</pre></span><pre>			Parent directories will be created as needed</pre></div>
<div class="cov"><span class="num"><pre>297</pre></span><pre>		:param kwargs: passed to the ``Scene.export`` method&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>298</pre></span><pre>		# build selectionlist for export</pre></div>
<div class="cov"><span class="num"><pre>299</pre></span><pre>		exp_slist = nt.toSelectionList(self.iter_animation(asNode=0))     </pre></div>
<div class="cov"><span class="num"><pre>300</pre></span><pre>		exp_slist.add(self.object())</pre></div>
<div class="cov"><span class="num"><pre>301</pre></span><pre>		return Scene.export(output_file, exp_slist, **kwargs ) </pre></div>
<div class="skip"><span class="num"><pre>302</pre></span><pre>			</pre></div>
<div class="cov"><span class="num"><pre>303</pre></span><pre>	def delete( self ):</pre></div>
<div class="cov"><span class="num"><pre>304</pre></span><pre>		&quot;&quot;&quot;AnimationHandle will disapear without a trace, no matter if it was created in</pre></div>
<div class="cov"><span class="num"><pre>305</pre></span><pre>		the current file or if it came from a referenced file&quot;&quot;&quot;</pre></div>
<div class="skip"><span class="num"><pre>306</pre></span><pre>		</pre></div>
<div class="cov"><span class="num"><pre>307</pre></span><pre>		if self.isReferenced():</pre></div>
<div class="cov"><span class="num"><pre>308</pre></span><pre>			FileReference(self.referenceFile()).remove()</pre></div>
<div class="cov"><span class="num"><pre>309</pre></span><pre>		else:</pre></div>
<div class="cov"><span class="num"><pre>310</pre></span><pre>			super(AnimationHandle, self).delete()</pre></div>
<div class="skip"><span class="num"><pre>311</pre></span><pre>		# END handle referencing</pre></div>
<div class="skip"><span class="num"><pre>312</pre></span><pre>			</pre></div>
<div class="skip"><span class="num"><pre>313</pre></span><pre>	#} END file io</pre></div>
</div>
</body>
</html>
